package main

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"log"
	"os"
	"path/filepath"
	"strings"
)

type FuncInfo struct {
	Name   string
	Params []string // type names
	Result string   // empty if void
}

var typeSize = map[string]int{
	"*byte":   8,
	"uintptr": 8,
	"uint32":  4,
	"uint8":   1,
	"*uint16": 8,
	"*uint32": 8,
	"*uint64": 8,
}

func sizeOf(t string) int {
	if sz, ok := typeSize[t]; ok {
		return sz
	}
	log.Fatalf("unsupported type in trampoline: %s", t)
	return 0
}

func main() {
	fset := token.NewFileSet()
	pkgDir := filepath.Join("..", "..", "internal", "ffi")
	pkgs, err := parser.ParseDir(fset, pkgDir, nil, parser.ParseComments)
	if err != nil {
		log.Fatal(err)
	}
	var funcs []FuncInfo
	for _, pkg := range pkgs {
		for _, f := range pkg.Files {
			for _, decl := range f.Decls {
				fd, ok := decl.(*ast.FuncDecl)
				if !ok || fd.Doc == nil {
					continue
				}
				var hasTag bool
				for _, c := range fd.Doc.List {
					if strings.HasPrefix(c.Text, "//simba:trampoline") {
						hasTag = true
						break
					}
				}
				if !hasTag {
					continue
				}
				info := FuncInfo{Name: fd.Name.Name}
				// params
				paramIndex := 0
				for _, p := range fd.Type.Params.List {
					typeStr := exprToString(p.Type)
					if len(p.Names) == 0 {
						name := fmt.Sprintf("arg%d", paramIndex)
						info.Params = append(info.Params, name+":"+typeStr)
						paramIndex++
					} else {
						for _, n := range p.Names {
							info.Params = append(info.Params, n.Name+":"+typeStr)
							paramIndex++
						}
					}
				}
				// results (assume 0 or 1)
				if fd.Type.Results != nil && len(fd.Type.Results.List) == 1 {
					info.Result = exprToString(fd.Type.Results.List[0].Type)
				}
				funcs = append(funcs, info)
			}
		}
	}
	if len(funcs) == 0 {
		log.Println("no trampolines found")
		return
	}

	generateArch("amd64", funcs)
	generateArch("arm64", funcs)
}

func exprToString(e ast.Expr) string {
	switch v := e.(type) {
	case *ast.StarExpr:
		return "*" + exprToString(v.X)
	case *ast.Ident:
		return v.Name
	default:
		return fmt.Sprintf("%T", e)
	}
}

func generateArch(arch string, funcs []FuncInfo) {
	var b strings.Builder
	b.WriteString("// Code generated by gen_trampolines; DO NOT EDIT.\n")
	fmt.Fprintf(&b, "//go:build %s\n// +build %s\n\n", arch, arch)
	b.WriteString("#include \"textflag.h\"\n\n")

	regOrder := map[string][]string{
		"amd64": {"DI", "SI", "DX", "CX", "R8", "R9"},
		"arm64": {"R0", "R1", "R2", "R3", "R4", "R5", "R6", "R7"},
	}[arch]

	for _, fn := range funcs {
		frame := 0
		for _, pair := range fn.Params {
			// align current offset to 8-byte boundary
			if frame%8 != 0 {
				frame += 8 - (frame % 8)
			}
			_, typ := split(pair)
			frame += sizeOf(typ)
		}
		if fn.Result != "" {
			if frame%8 != 0 {
				frame += 8 - (frame % 8)
			}
			_, typ := split(fn.Result)
			frame += sizeOf(typ)
		}
		// comment line
		fmt.Fprintf(&b, "// func %s(", fn.Name)
		// param list comment
		fmt.Fprintf(&b, ")")
		if fn.Result != "" {
			fmt.Fprintf(&b, " %s", fn.Result)
		}
		b.WriteString("\n")

		fmt.Fprintf(&b, "TEXT Â·%s(SB), NOSPLIT, $0-%d\n", fn.Name, frame)
		// move params
		offset := 0
		for i, pair := range fn.Params {
			name, typ := split(pair)
			// ensure offset is 8-byte aligned before reading argument
			if offset%8 != 0 {
				offset += 8 - (offset % 8)
			}
			sz := sizeOf(typ)
			reg := regOrder[i]
			if arch == "amd64" {
				b.WriteString(fmt.Sprintf("    MOVQ %s+%d(FP), %s\n", name, offset, reg))
			} else { // arm64 uses MOVD
				b.WriteString(fmt.Sprintf("    MOVD %s+%d(FP), %s\n", name, offset, reg))
			}
			offset += sz
		}
		// call
		rustName := strings.TrimSuffix(fn.Name, "_raw")
		b.WriteString(fmt.Sprintf("    CALL %s(SB)\n", rustName))
		// return move
		if fn.Result != "" {
			if arch == "amd64" {
				inst := "MOVL"
				destReg := "AX"
				if fn.Result == "uint8" {
					inst, destReg = "MOVB", "AL"
				}
				b.WriteString(fmt.Sprintf("    %s %s, ret+%d(FP)\n", inst, destReg, offset))
			} else {
				// arm64
				inst := "MOVW"
				if fn.Result == "uint8" {
					inst = "MOVBU"
				}
				b.WriteString(fmt.Sprintf("    %s R0, ret+%d(FP)\n", inst, offset))
			}
		}
		b.WriteString("    RET\n\n")
	}

	path := fmt.Sprintf("syso_%s.s", arch)
	if err := os.WriteFile(path, []byte(b.String()), 0644); err != nil {
		log.Fatalf("write %s: %v", path, err)
	}
	fmt.Printf("generated %s with %d trampolines\n", path, len(funcs))
}

func split(pair string) (name string, typ string) {
	parts := strings.Split(pair, ":")
	if len(parts) == 2 {
		return parts[0], parts[1]
	}
	// no name, only type
	return "", pair
}
